<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Outline Highlight Demo</title>
    <link rel="stylesheet" href="./style.css" />
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js",
          "three/examples/jsm/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js",
          "three/examples/jsm/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/RenderPass.js",
          "three/examples/jsm/postprocessing/OutlinePass": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/postprocessing/OutlinePass.js"
        }
      }
    </script>
  </head>
  <body>
    <canvas id="viewport"></canvas>
    <button id="outlineToggle" class="outline-toggle outline-toggle--on">Outline: On</button>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';
      import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer';
      import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass';
      import { OutlinePass } from 'three/examples/jsm/postprocessing/OutlinePass';

      const canvas = /** @type {HTMLCanvasElement} */ (document.getElementById('viewport'));
      const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0xffffff, 1);

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(6, 4, 10);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      const directional = new THREE.DirectionalLight(0xffffff, 1.2);
      directional.position.set(5, 10, 7);
      scene.add(directional);

      const group = new THREE.Group();
      scene.add(group);

      const baseGeometry = new THREE.IcosahedronGeometry(1, 2);
      for (let i = 0; i < 24; i += 1) {
        const material = new THREE.MeshStandardMaterial();
        material.color.setHSL(Math.random(), 0.6, 0.5);
        const mesh = new THREE.Mesh(baseGeometry, material);
        mesh.position.set((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 4, (Math.random() - 0.5) * 8);
        mesh.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        mesh.scale.setScalar(Math.random() * 0.8 + 0.3);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);
      }

      const floorMaterial = new THREE.MeshStandardMaterial({ color: 0xe2e8f0 });
      const floor = new THREE.Mesh(new THREE.PlaneGeometry(30, 30), floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = -2.5;
      floor.receiveShadow = true;
      scene.add(floor);

      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      const composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));

      const resolution = new THREE.Vector2(window.innerWidth, window.innerHeight);
      const selectionPass = new OutlinePass(resolution.clone(), scene, camera);
      selectionPass.edgeStrength = 3.0;
      selectionPass.edgeGlow = 0.0;
      selectionPass.edgeThickness = 1.0;
      selectionPass.visibleEdgeColor.set(0x2563eb);
      selectionPass.hiddenEdgeColor.set(0x1e3a8a);
      composer.addPass(selectionPass);

      const hoverPass = new OutlinePass(resolution.clone(), scene, camera);
      hoverPass.edgeStrength = 3.5;
      hoverPass.edgeGlow = 0.0;
      hoverPass.edgeThickness = 1.2;
      hoverPass.visibleEdgeColor.set(0xf97316);
      hoverPass.hiddenEdgeColor.set(0xc2410c);
      composer.addPass(hoverPass);

      /** @type {Set<THREE.Mesh>} */
      const selectedMeshes = new Set();
      /** @type {THREE.Mesh | null} */
      let hoveredMesh = null;
      let outlineEnabled = true;
      let pointerDown = null;

      const selectableMeshes = [];
      scene.traverse((child) => {
        if (child.isMesh) {
          selectableMeshes.push(child);
        }
      });

      /**
       * @param {MouseEvent | PointerEvent} event
       */
      function updatePointer(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -(((event.clientY - rect.top) / rect.height) * 2 - 1);
      }

      function updateOutlinePasses() {
        selectionPass.selectedObjects = Array.from(selectedMeshes);
        const hoverTargets = hoveredMesh && !selectedMeshes.has(hoveredMesh) ? [hoveredMesh] : [];
        hoverPass.selectedObjects = hoverTargets;

        selectionPass.enabled = outlineEnabled && selectionPass.selectedObjects.length > 0;
        hoverPass.enabled = outlineEnabled && hoverTargets.length > 0;
      }

      function setHovered(mesh) {
        if (hoveredMesh === mesh) return;
        hoveredMesh = mesh;
        updateOutlinePasses();
      }

      function toggleSelection(mesh, additive) {
        if (!mesh) {
          if (!additive) {
            selectedMeshes.clear();
            updateOutlinePasses();
          }
          return;
        }

        if (!additive) {
          selectedMeshes.clear();
          selectedMeshes.add(mesh);
        } else if (selectedMeshes.has(mesh)) {
          selectedMeshes.delete(mesh);
        } else {
          selectedMeshes.add(mesh);
        }
        updateOutlinePasses();
      }

      renderer.domElement.addEventListener('pointerdown', (event) => {
        if (event.button !== 0) return;
        pointerDown = { x: event.clientX, y: event.clientY };
      });

      renderer.domElement.addEventListener('pointermove', (event) => {
        updatePointer(event);
        raycaster.setFromCamera(pointer, camera);
        const intersections = raycaster.intersectObjects(selectableMeshes, false);
        setHovered(intersections.length > 0 ? intersections[0].object : null);
      });

      renderer.domElement.addEventListener('pointerleave', () => {
        setHovered(null);
      });

      renderer.domElement.addEventListener('pointerup', (event) => {
        if (event.button !== 0 || !pointerDown) return;
        const dx = event.clientX - pointerDown.x;
        const dy = event.clientY - pointerDown.y;
        pointerDown = null;
        if (Math.hypot(dx, dy) > 4) return;

        updatePointer(event);
        raycaster.setFromCamera(pointer, camera);
        const intersections = raycaster.intersectObjects(selectableMeshes, false);
        const target = intersections.length > 0 ? intersections[0].object : null;
        toggleSelection(target, event.shiftKey);
      });

      function onResize() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
        composer.setSize(width, height);
        selectionPass.resolution.set(width, height);
        hoverPass.resolution.set(width, height);
      }

      window.addEventListener('resize', onResize);

      const toggleButton = document.getElementById('outlineToggle');
      function updateToggleButton() {
        toggleButton.classList.toggle('outline-toggle--on', outlineEnabled);
        toggleButton.classList.toggle('outline-toggle--off', !outlineEnabled);
        toggleButton.textContent = outlineEnabled ? 'Outline: On' : 'Outline: Off';
        updateOutlinePasses();
      }

      toggleButton.addEventListener('click', () => {
        outlineEnabled = !outlineEnabled;
        updateToggleButton();
      });

      updateOutlinePasses();

      function animate() {
        controls.update();
        if (outlineEnabled) {
          composer.render();
        } else {
          renderer.render(scene, camera);
        }
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
